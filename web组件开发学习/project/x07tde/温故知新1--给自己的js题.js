1.词法作用域：(js是基于词法作用域的)无论函数在哪被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。
（作用域链只会在定义的地方向上查找，而不会在调用的地方向上查找。结合以下例子仔细体会）
	function foo(){
		console.log(a);
	}	
	function bar(){
		var a=3;
		foo();
	}
	//若bar()在这里执行是什么结果
	var a=2;//若此处a没定义则ReferenceError错误
	bar();//函数执行结果2
2.IIFE是什么？机制？优缺点？典型应用场景？
IIFE：(Immediately Invoked Function Expression)立即执行函数表达式。
//函数名对IIFE并不是必须的，IIFE最常见形式是使用一个匿名函数，但具名函数具有匿名函数的所有优势且语义明确
形式1：(function(){}());//这两种形式功能上是一致的
形式2：(function[name](){})();//第一个括号将函数变成一个表达式，第二个括号执行了这个函数

3.闭包？机制？典型应用？
4.es6中 let/const/module/export/import
5.模块依赖加载器/管理器工作原理？
6.词法作用域与动态作用域的区别？
7.es6中 => ?

准备：必知的小知识点

8.变量存储在哪里？程序需要时如何找到他们？(作用域)
9.传统编译语言流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为编译：
词法分析、语法分析、代码生成。（词法单元流，抽象语法树）
10.任何JavaScript代码片段在执行前都要进行编译（通常就在执行前）。
（涉及的3个方面：
引擎：从头到尾负责整个JavaScript程序的编译及执行过程；
编译器：负责语法分析及代码生成；
作用域：负责收集并维护由所声明的标识符（变量）组成的一系列查询，
并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权；
）
（一个变量定义与赋值（var a=2;）的过程的通俗描述：
i:遇到 var a,编译器会询问作用域是否已由该名称的变量存在于同一个作用域的
集合中。若存在，编译器会忽略该声明，继续执行编译；否则他会要求作用域在当前
作用域集合中声明一个新的变量，并命名为 a。
ii：接下来编译器会为浏览器引擎生成运行时所需的代码，这些代码被用来处理 a=2
这个赋值操作。引擎运行时会首先询问作用域，在当前作用域的集合中是否存在一个
叫作a的变量。若存在引擎就会使用这个变量；若不存在引擎会继续查找该变量。
若引擎最终找到了变量a,就会将2赋值给它。否则浏览器就会抛出一个异常。
总结：变量的复制操作会执行两个动作，首先浏览器会在当前作用域中声明一个变量
（如果之前没有生命过），然后在运行时引擎会在作用域中查找该变量，如果能够
找到机会对它赋值。
）
11.LHS查询与RHS查询。
当变量出现在赋值操作左侧时进行LHS查询。当变量不出现在赋值操作左侧（即非左侧）
是进行RHS查询。
LHS查询若变量不存在则（在非严格模式下）就会创建一个具有该名称的变量。
RHS查询若变量不存在就会抛出ReferenceError。


12.遮蔽效应（作用域链中存在多个同名变量时，里层的变量会遮蔽外层变量）
13.欺骗词法作用域的几种方式：eval()(只接受含代码的字符串或变量名),
with(){},若对with中没有的属性赋值，会执行LHS查询，属性会被赋值给全局对象。
欺骗词法作用域会导致引擎无法再编译时对对代码进行优化，大大影响代码执行性能。


14.函数声明与函数表达式的区别？怎样辨别函数声明与函数表达式？（是否提升）
区分函数声明与函数表达式最简单的方法是看function关键字出现在声明中的位置（
不仅仅是一行代码，而是整个声明中的位置）。若function是声明中的第一个词，那
么就是一个函数声明，否则就是一个函数表达式。
函数声明会提升。

15.




